<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Auto Generated Documentation &#8212; scatter docs 2.5 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-NanoObjects">
<span id="auto-generated-documentation"></span><h1>Auto Generated Documentation<a class="headerlink" href="#module-NanoObjects" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="NanoObjects.CylinderNanoObject">
<em class="property">class </em><code class="descclassname">NanoObjects.</code><code class="descname">CylinderNanoObject</code><span class="sig-paren">(</span><em>pargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.CylinderNanoObject" title="Permalink to this definition">¶</a></dt>
<dd><p>A cylinder nano-object. The canonical (unrotated) version
has the circular-base in the x-y plane, with the length along z.</p>
<dl class="docutils">
<dt>self.pargs contains parameters:</dt>
<dd><p class="first">rho_ambient : the cylinder density
rho_object : the solvent density
radius : (default 1.0) the cylinder radius
length : (default 1.0) the cylinder length</p>
<p>eta,phi,eta: Euler angles
x0, y0, z0 : the position of cylinder COM relative to origin
The object is rotated first about origin, then translated to</p>
<blockquote class="last">
<div>where x0, y0, and z0 define it to be.</div></blockquote>
</dd>
<dt>these are calculated after the fact:</dt>
<dd>delta_rho : rho_ambient - rho1</dd>
</dl>
<dl class="method">
<dt id="NanoObjects.CylinderNanoObject.V">
<code class="descname">V</code><span class="sig-paren">(</span><em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.CylinderNanoObject.V" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the intensity of the real-space potential at the
given real-space coordinates.
Returns 1 if in the space, 0 otherwise.
Can be arrays.
Rotate then translate.</p>
<blockquote>
<div>rotation_matrix is an extra rotation to add on top of the built
in rotation (from eta, phi, theta elements in object)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.CylinderNanoObject.form_factor">
<code class="descname">form_factor</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.CylinderNanoObject.form_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex-amplitude of the form factor at the given
q-coordinates.</p>
<blockquote>
<div><p>The first set of q are assumed to be that of the root qx,qy,qz
The next sets are the parent coordinates. These are only supplied if the parent is not the root
The root q is only necessary for the form factor, where the phase factor needs to be calculated</p>
<blockquote>
<div>with respect to the origin of that coordinate system.</div></blockquote>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NanoObjects.NanoObject">
<em class="property">class </em><code class="descclassname">NanoObjects.</code><code class="descname">NanoObject</code><span class="sig-paren">(</span><em>pargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a nano-object, which can then be placed within a lattice
for computing scattering data. A nano-object can be anisotropic.</p>
<blockquote>
<div>This is the base class all nano-objects should inherit</div></blockquote>
<dl class="method">
<dt id="NanoObjects.NanoObject.P_beta">
<code class="descname">P_beta</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em>, <em>approx=False</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.P_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns P (isotropic_form_factor_squared) and beta_ratio.
This function can be highly optimized in derived classes.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.V">
<code class="descname">V</code><span class="sig-paren">(</span><em>rvec</em>, <em>rotation_elements=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.V" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the intensity of the real-space potential at the
given real-space coordinates.
rvec : [x,y,z]</p>
<p>This method should be overwritten.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.beta_ratio">
<code class="descname">beta_ratio</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em>, <em>approx=False</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.beta_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the beta ratio: <a href="#id1"><span class="problematic" id="id2">|</span></a>&lt;F(q)&gt;|^2 / &lt;<a href="#id3"><span class="problematic" id="id4">|</span></a>F(q)|^2&gt;
This ratio depends on polydispersity: for a monodisperse system, beta = 1 for all q.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.check_arg">
<code class="descname">check_arg</code><span class="sig-paren">(</span><em>name</em>, <em>pargs</em>, <em>default=0</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.check_arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Check dictionary for a parameter. If not there, set the parg
to the default.</p>
<p>Returns the result in both cases</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor">
<code class="descname">form_factor</code><span class="sig-paren">(</span><em>qvector</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex-amplitude of the form factor at the given
q-coordinates.</p>
<blockquote>
<div>qvector is an array as such: [qx, qy, qz] where qx, qy, qz need
matching dimensions</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor_isotropic">
<code class="descname">form_factor_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the particle form factor, averaged over every possible orientation.
Math:</p>
<blockquote>
<div>solid angle is dS = r^2 sin(th) dth dphi
ignore the r part (or q)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor_numerical">
<code class="descname">form_factor_numerical</code><span class="sig-paren">(</span><em>qvector</em>, <em>num_points=100</em>, <em>size_scale=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor_numerical" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a brute-force calculation of the form-factor, using the
realspace potential. This is computationally intensive and should be
avoided in preference to analytical functions which are put into the
&#8220;form_factor(qx,qy,qz)&#8221; function.</p>
<blockquote>
<div><p>qvector : float arrays the reciprocal space coordinates
num_points : int, optional, the number of points to sample
rotation_elements : rotation matrix</p>
<p>coord : the complex form factor</p>
<p>Note : NOT TESTED YET</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor_orientation_spread">
<code class="descname">form_factor_orientation_spread</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em>, <em>orientation_spread=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor_orientation_spread" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the particle form factor, averaged over some orientations.
This function is intended to be used to create a effective form factor
when particle orientations have some distribution.</p>
<p>orientation_spread: If set, overrides the one in pargs. If not set, searches in pargs.</p>
<dl class="docutils">
<dt>The default distribution is uniform. Endpoints are given by pargs[&#8216;orientation_spread&#8217;]</dt>
<dd>which are phi_start, phi_end, theta_start, theta_end</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor_squared">
<code class="descname">form_factor_squared</code><span class="sig-paren">(</span><em>qvector</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor_squared" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the square of the form factor.
Value returned is real.
Note : Need to implement form_factor.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor_squared_isotropic">
<code class="descname">form_factor_squared_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor_squared_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the square of the form factor, under the assumption of
random orientation. In other words, we average over every possible
orientation.
This value is denoted by P(q)</p>
<dl class="docutils">
<dt>Note this is different from form_factor_isotropic, where the difference is:</dt>
<dd><a href="#id5"><span class="problematic" id="id6">|</span></a>&lt;F&gt;|^2 versis &lt;<a href="#id7"><span class="problematic" id="id8">|</span></a>F|^2&gt;. See &#8220;Periodic lattices of arbitrary
nano-objects: modeling and applications for self-assembled systems&#8221;
(DOI: 10.1107/S160057671302832X)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor_squared_numerical">
<code class="descname">form_factor_squared_numerical</code><span class="sig-paren">(</span><em>qvector</em>, <em>num_points=100</em>, <em>size_scale=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor_squared_numerical" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the square of the form factor.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.form_factor_squared_orientation_spread">
<code class="descname">form_factor_squared_orientation_spread</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em>, <em>orientation_spread=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.form_factor_squared_orientation_spread" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the particle form factor, averaged over some orientations.
This function is intended to be used to create a effective form factor
when particle orientations have some distribution.</p>
<p>orientation_spread: If set, overrides the one in pargs. If not set, searches in pargs.</p>
<dl class="docutils">
<dt>The default distribution is uniform. Endpoints are given by pargs[&#8216;orientation_spread&#8217;]</dt>
<dd>which are phi_start, phi_end, theta_start, theta_end</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.func_orientation_spread">
<code class="descname">func_orientation_spread</code><span class="sig-paren">(</span><em>q</em>, <em>func</em>, <em>dtype</em>, <em>num_phi=50</em>, <em>num_theta=50</em>, <em>orientation_spread=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.func_orientation_spread" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an orientation average of function func from a sphere of points whose radius is q</p>
<p>q : q points, can be an array
func :  should take a qvector as sole argument ([qx,qy,qz])</p>
<blockquote>
<div>This is a general function used by form_factors calcs (isotropic or orient spread)</div></blockquote>
<p>dtype :  the data type (complex or float)</p>
<dl class="docutils">
<dt>orientation_spread: If set, overrides the one in pargs. If not set,</dt>
<dd>searches in pargs.  The default distribution is uniform. Endpoints
are given by pargs[&#8216;orientation_spread&#8217;] which are phi_start,
phi_end, theta_start, theta_end</dd>
</dl>
<blockquote>
<div>F : result of function func, averaged over specified orientations</div></blockquote>
<p>This function is intended to be used to create a effective form factor
when particle orientations have some distribution.
Math:</p>
<blockquote>
<div>solid angle is dS = r^2 sin(th) dth dphi
ignore the r part (or q)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.get_phase">
<code class="descname">get_phase</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the phase factor from the shift, for the q position.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.map_coord">
<code class="descname">map_coord</code><span class="sig-paren">(</span><em>coord</em>, <em>rotation_matrix</em>, <em>origin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.map_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the real space coordinates from the parent object to child
object&#8217;s coordinates (this one), using the specified rotation matrix
and origin. This sets the 0 and orientation of sample to align with
internal orientation. This function is generally recursively called for
every traversal into child coordinates.</p>
<blockquote>
<div><p>coord : float array, the r coordinates to map
rotation_matrix : 3x3 ndarray, the rotation matrix
origin : length 3 array (optional), the origin (default [0,0,0])</p>
<p>coord : the rotated coordinates</p>
<p>Most objects will use map_rcoord and map_qcoord
instead, which know what to do with the internal rotation
matrices of the objects.</p>
<p>The slowest varying index of r is the coordinate</p>
<p>map_coord (to specify your own rotations/translations)
set_origin
set_angles</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.map_qcoord">
<code class="descname">map_qcoord</code><span class="sig-paren">(</span><em>qcoord</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.map_qcoord" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the reciprocal space coordinates from the parent object to
child object (this one).  The origin shift is not needed here, and so
this function basically just rotates the coordinates given, using the
internal rotation matrix.
Translation is a phase which is computed separately.</p>
<blockquote>
<div><dl class="docutils">
<dt>qcoord</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array, the q coordinates to rotate.</span><dd>Leftermost index are the q components: [qx, qy, qz] where qx,
qy, qz are any dimension</dd>
</dl>
<p>qcoord : the rotated coordinates</p>
<p>map_coord (to specify arbitrary rotation matrix)
set_origin
set_angles</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.map_rcoord">
<code class="descname">map_rcoord</code><span class="sig-paren">(</span><em>rcoord</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.map_rcoord" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the real space coordinates from the parent object to child
object&#8217;s coordinates (this one), using the internal rotation matrix and
origin (set by set_angles, set_origin). This sets the 0 and orientation
of sample to align with internal orientation. This function is
generally recursively called for every traversal into child
coordinates.</p>
<blockquote>
<div><dl class="docutils">
<dt>rcoord</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array, the r coordinates to map</span><dd>Leftermost index are the r components: [x, y, z] where
x, y, z are any dimension</dd>
</dl>
<p>qcoord : the rotated coordinates</p>
<p>map_coord (to specify your own rotations/translations)
set_origin
set_angles</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.projections">
<code class="descname">projections</code><span class="sig-paren">(</span><em>length</em>, <em>npoints=100</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.projections" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the xy, yz, and xz projections (in that order).</p>
<p>This is a convenience routine to allow one to see approximately
what the nano object looks like. Useful when creating new composite
nano objects.</p>
<dl class="docutils">
<dt>length</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">length of the box to compute the projections.</span><dd>Will compute a 3D box of [-length, +length] in x, y and z</dd>
<dt>npoints</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">the number of points to calculate per dimension</span><dd>default 100
WARNING : This creates a npoints x npoints x npoints array</dd>
</dl>
<p>V_xy : the xy projection
V_xz : the xz projection
V_yz : the xz projection</p>
<p>To compute the projection, this function must first compute a 3D
density field of the object, and add various projections.  This
code can become very slow and memory intensive if npoints is too
large.</p>
<p>It also is strongly reliant on how well Obj.V() was coded.  When
adding new NanoObjects, be careful to program in the Obj.V()
function properly.
This is a great tool for CompositeNanoObjects</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.rebuild">
<code class="descname">rebuild</code><span class="sig-paren">(</span><em>pargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows the object to have its potential
arguments (pargs) updated. Note that this doesn&#8217;t
replace the old pargs entirely. It only modifies
(or adds) the key/values provided by the new pargs.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.rotation_elements">
<code class="descname">rotation_elements</code><span class="sig-paren">(</span><em>eta</em>, <em>phi</em>, <em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.rotation_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts angles into an appropriate rotation matrix.</p>
<dl class="docutils">
<dt>Three-axis rotation:</dt>
<dd><ol class="first arabic simple">
<li>Rotate about +z by eta (counter-clockwise in x-y plane)</li>
</ol>
<p class="last">2. Tilt by phi with respect to +z (rotation about y-axis,
clockwise in x-z plane) then
3. rotate by theta in-place (rotation about z-axis,
counter-clockwise in x-y plane)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>eta=None</em>, <em>phi=None</em>, <em>theta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Update one or multiple orientation angles (degrees).
These are the typical Euler coordinates.</p>
<blockquote>
<div>rotation_elements</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.set_origin">
<code class="descname">set_origin</code><span class="sig-paren">(</span><em>x0=None</em>, <em>y0=None</em>, <em>z0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.set_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the origin of the sample.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.thresh_array">
<code class="descname">thresh_array</code><span class="sig-paren">(</span><em>r</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.thresh_array" title="Permalink to this definition">¶</a></dt>
<dd><p>threshold array to have minimum value.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.to_short_string">
<code class="descname">to_short_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.to_short_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a short string describing the object&#8217;s variables.
(Useful for distinguishing objects of the same class.)</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.NanoObject.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.NanoObject.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string describing the object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NanoObjects.PolydisperseNanoObject">
<em class="property">class </em><code class="descclassname">NanoObjects.</code><code class="descname">PolydisperseNanoObject</code><span class="sig-paren">(</span><em>baseNanoObjectClass</em>, <em>pargs={}</em>, <em>argname=None</em>, <em>argstdname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a polydisperse nano-object, which has a distribution in
argname of width argstdname
if not specified, argname defaults to the parameter &#8216;radius&#8217;</p>
<blockquote>
<div>and argstdname defaults to &#8216;sigma_R&#8217;</div></blockquote>
<dl class="docutils">
<dt>the width is in absolute units (not a percentage or ratio of the</dt>
<dd>argument it&#8217;s varying)</dd>
</dl>
<p>Note : this is slow, but more general. If slow, it may be worth hard
coding the form factor (if  not too complex).</p>
<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.V">
<code class="descname">V</code><span class="sig-paren">(</span><em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.V" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average potential</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.beta_numerator">
<code class="descname">beta_numerator</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.beta_numerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the numerator of the beta ratio: <a href="#id9"><span class="problematic" id="id10">|</span></a>&lt;&lt;F(q)&gt;_d&gt;_iso|^2</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.beta_numerator_iso_external">
<code class="descname">beta_numerator_iso_external</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.beta_numerator_iso_external" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the beta numerator under the assumption that the orientational
averaging is done last. That is, instead of calculating <a href="#id11"><span class="problematic" id="id12">|</span></a>&lt;&lt;F&gt;&gt;_iso|^2, we
calculate &lt;<a href="#id13"><span class="problematic" id="id14">|</span></a>&lt;F&gt;|^2&gt;_iso</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.beta_ratio">
<code class="descname">beta_ratio</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em>, <em>approx=False</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.beta_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the beta ratio: <a href="#id15"><span class="problematic" id="id16">|</span></a>&lt;&lt;F(q)&gt;_iso&gt;_d|^2 / &lt;&lt;<a href="#id17"><span class="problematic" id="id18">|</span></a>F(q)|^2&gt;_iso&gt;_d This
ratio depends on polydispersity: for a monodisperse system, beta = 1
for all q.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.dist_sum">
<code class="descname">dist_sum</code><span class="sig-paren">(</span><em>funcname</em>, <em>shape</em>, <em>dtype</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.dist_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum the function with name &#8216;funcname&#8217; over variable &#8216;vec&#8217; over the current
distribution.
Forwards other keyword arguments to function</p>
<p>funcname : the function name
shape : the shape of the result
dtype : the data type
args : arguments to the function
components : specifies if vec is of form [qx,qy,qz] (True)</p>
<blockquote>
<div>or just q (False)</div></blockquote>
<p>kwargs : keyword arguments to function</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.distribution">
<code class="descname">distribution</code><span class="sig-paren">(</span><em>spread=2.5</em>, <em>force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the probability distribution.
Returns the previously calculated distribution</p>
<blockquote>
<div>or recomputes if doesn&#8217;t exist.</div></blockquote>
<p>Run rebuild to reset.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.distribution_gaussian">
<code class="descname">distribution_gaussian</code><span class="sig-paren">(</span><em>mean=1.0</em>, <em>rms=0.01</em>, <em>num_points=11</em>, <em>spread=2.5</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.distribution_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian distribution of parameters.</p>
<p>mean : the mean value</p>
<p>rms : the rms value</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.distribution_lognormal">
<code class="descname">distribution_lognormal</code><span class="sig-paren">(</span><em>mean=1.0</em>, <em>rms=0.01</em>, <em>num_points=91</em>, <em>spread=10</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.distribution_lognormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Lognormal distribution of parameters.</p>
<p>mean : this here will mean the scale of the lognorm (the higher the further the peak)</p>
<p>rms : this will mean the shape of the lognorm distribution</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.form_factor">
<code class="descname">form_factor</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.form_factor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns the complex-amplitude of the form factor at the given</dt>
<dd>&lt;F&gt;_d</dd>
</dl>
<p>q-coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.form_factor_distavg_squared">
<code class="descname">form_factor_distavg_squared</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.form_factor_distavg_squared" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id19"><span class="problematic" id="id20">|</span></a>&lt;F&gt;_d|^2</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.form_factor_isotropic">
<code class="descname">form_factor_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.form_factor_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isotropic form factor
&lt; &lt;F&gt;_iso &gt;_d</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.form_factor_squared">
<code class="descname">form_factor_squared</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.form_factor_squared" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the square of the form factor.</p>
<p>&lt;<a href="#id21"><span class="problematic" id="id22">|</span></a>F|^2&gt;_d</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.form_factor_squared_isotropic">
<code class="descname">form_factor_squared_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.form_factor_squared_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isotropic form factor
&lt; &lt;<a href="#id23"><span class="problematic" id="id24">|</span></a>F|^2&gt;_iso &gt;_d</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.rebuild">
<code class="descname">rebuild</code><span class="sig-paren">(</span><em>pargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows the object to have its potential
arguments (pargs) updated. Note that this doesn&#8217;t
replace the old pargs entirely. It only modifies
(or adds) the key/values provided by the new pargs.</p>
<p>For a polydisperse object, need to update pargs for elements in
distribution, omitting variable that&#8217;s being modified.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PolydisperseNanoObject.volume">
<code class="descname">volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PolydisperseNanoObject.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>ret avg volume</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NanoObjects.PyramidNanoObject">
<em class="property">class </em><code class="descclassname">NanoObjects.</code><code class="descname">PyramidNanoObject</code><span class="sig-paren">(</span><em>pargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PyramidNanoObject" title="Permalink to this definition">¶</a></dt>
<dd><p>A square-based truncated pyramid nano-object. The canonical (unrotated) version
has the square-base in the x-y plane, with the peak pointing along +z.
The base-edges are parallel to the x-axis and y-axis (i.e. the corners
point at 45 degrees to axes.
Edge length of base is 2*R</p>
<dl class="docutils">
<dt>A regular pyramid (for octahedra) will have equilateral triangles as faces</dt>
<dd>and not be truncated.
Thus H = sqrt(2)*R and face_angle = arctan(sqrt(2)) = 54.7356 degrees
Only set &#8220;R&#8221; to get this regular pyramid.</dd>
<dt>From [Kevin&#8217;s website] (<a class="reference external" href="http://gisaxs.com/index.php/Form_Factor:Pyramid">http://gisaxs.com/index.php/Form_Factor:Pyramid</a>):</dt>
<dd>For pyramid of base edge-length 2R, and height H. The angle of the
pyramid walls is lpha. If H &lt; R/       anlpha then the pyramid is
truncated (flat top).</dd>
</dl>
<p>Originally from:
Lazzari, Rémi. &#8220;IsGISAXS: a program for grazing-incidence small-angle X-ray
scattering analysis of supported islands.&#8221; Journal of Applied
Crystallography 35.4 (2002): 406-421.
doi:10.1107/S0021889802006088</p>
<dl class="method">
<dt id="NanoObjects.PyramidNanoObject.V">
<code class="descname">V</code><span class="sig-paren">(</span><em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PyramidNanoObject.V" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the intensity of the real-space potential at the
given real-space coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PyramidNanoObject.form_factor">
<code class="descname">form_factor</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PyramidNanoObject.form_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex-amplitude of the form factor at the given
q-coordinates.
From Kevin&#8217;s website</p>
<dl class="docutils">
<dt>Notes</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">I have checked that the q=0 scaling scales as volume and it does.</span><dd>So composite objects (sums and differences) should scale properly.
For example, for a regular pyramid (equilateral triangles), the volume
is 4*sqrt(2)/3*R^3 where 2*R is the edge length at the base. I checked
and the q=0 scattering is exactly volume^2 as it should be
(assuming other prefactors are 1).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.PyramidNanoObject.volume">
<code class="descname">volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.PyramidNanoObject.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of a pyramid.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NanoObjects.RandomizedNanoObject">
<em class="property">class </em><code class="descclassname">NanoObjects.</code><code class="descname">RandomizedNanoObject</code><span class="sig-paren">(</span><em>baseNanoObjectClass</em>, <em>pargs={}</em>, <em>argdict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a nano-object of which certain parameters are randomized</p>
<dl class="docutils">
<dt>This is a little more useful than a polydisperse nano object</dt>
<dd>in that it allows you to randomize a few parameters at once.</dd>
</dl>
<p>The more parameters you randomize, the higher you may want to set
nsamples for accuracy.</p>
<dl class="docutils">
<dt>pargs</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">the base potential arguments (parameters) of the system</span><dd><p class="first">In pargs, you need to specify the parameters necessary to build the
base NanoObject Class supplied. On top of this, you also need to
specify one more parameter:</p>
<blockquote class="last">
<div>&#8216;distribution_num_points&#8217; : this is the number of points to
randomly sample. Basically, this class will spawn this number
of nano-objects, with each nano-object having parameters that
are randomly varied by argdict (described next).
This defaults to 21. You should set this larger for better
accuracy.</div></blockquote>
</dd>
<dt>argdict:</dt>
<dd><p class="first">This will be randomized parameters. These will override the pargs.
It is a dictionary, with the key of the dictionary entries being
the parameter names. The entries themselves are dictionaries
containing more information. For example, for a polydisperse sphere
whose radius follows the lognormal distribution, you would put:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>{</dt>
<dd><dl class="first docutils">
<dt>&#8216;radius&#8217;</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">{</span><dd><blockquote class="first">
<div>&#8216;distribution_type&#8217; : &#8216;lognormal&#8217;, 
&#8216;mean&#8217; : 1, # average val
&#8216;sigma&#8217; : .1,  #std deviation</div></blockquote>
<p class="last">},</p>
</dd>
</dl>
<p class="last"># add more arguments here etc...</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>Call &#8216;build_objects&#8217; to build a list of objects with parameters
randomly varied. The form factor etc will then be computed by averaging
over these quanties. Note that form_factor_squared != form_factor^2 in
this case! See Beta(q) in [1] for more information.</p>
<p>[1] Yager, Kevin G., et al. &#8220;Periodic lattices of arbitrary nano-objects:
modeling and applications for self-assembled systems.&#8221; Journal of
Applied Crystallography 47.1 (2014): 118-129.</p>
<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.V">
<code class="descname">V</code><span class="sig-paren">(</span><em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.V" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average potential</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.beta_numerator">
<code class="descname">beta_numerator</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.beta_numerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the numerator of the beta ratio: <a href="#id25"><span class="problematic" id="id26">|</span></a>&lt;&lt;F(q)&gt;_d&gt;_iso|^2</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.beta_numerator_iso_external">
<code class="descname">beta_numerator_iso_external</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.beta_numerator_iso_external" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the beta numerator under the assumption that the orientational
averaging is done last. That is, instead of calculating <a href="#id27"><span class="problematic" id="id28">|</span></a>&lt;&lt;F&gt;&gt;_iso|^2, we
calculate &lt;<a href="#id29"><span class="problematic" id="id30">|</span></a>&lt;F&gt;|^2&gt;_iso</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.beta_ratio">
<code class="descname">beta_ratio</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em>, <em>approx=False</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.beta_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the beta ratio: <a href="#id31"><span class="problematic" id="id32">|</span></a>&lt;&lt;F(q)&gt;_iso&gt;_d|^2 / &lt;&lt;<a href="#id33"><span class="problematic" id="id34">|</span></a>F(q)|^2&gt;_iso&gt;_d This
ratio depends on polydispersity: for a monodisperse system, beta = 1
for all q.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.build_objects">
<code class="descname">build_objects</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.build_objects" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Build a list of objects whose parameters are randomly</dt>
<dd>sampled according to a probability distribution.</dd>
</dl>
<p>Compute the probability distribution.
Returns the previously calculated distribution</p>
<blockquote>
<div>or recomputes if doesn&#8217;t exist.</div></blockquote>
<dl class="docutils">
<dt>Since we can have multipe parameters with different</dt>
<dd>distributions, this is a distribution list.</dd>
</dl>
<p>Run rebuild to reset.
# TODO : Make distribution from numbers</p>
<blockquote>
<div><p>when summing run same object, rebuild and re-calculate
since it&#8217;s random, you don&#8217;t want to cache either
&#8216;distribution_num_points&#8217; : 21,
{&#8216;radius&#8217; : {&#8216;distribution_type&#8217; : &#8216;gaussian&#8217;,</p>
<blockquote>
<div># parameters specific to distribution
&#8216;avg&#8217; : 1, # average val
&#8216;std&#8217; : .1,  #std deviation
&#8216;spread&#8217; : 2.5}}</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.dist_sum">
<code class="descname">dist_sum</code><span class="sig-paren">(</span><em>funcname</em>, <em>shape</em>, <em>dtype</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.dist_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum the function with name &#8216;funcname&#8217; over variable &#8216;vec&#8217; over the current
distribution.
Forwards other keyword arguments to function</p>
<p>funcname : the function name
shape : the shape of the result
dtype : the data type
args : arguments to the function
components : specifies if vec is of form [qx,qy,qz] (True)</p>
<blockquote>
<div>or just q (False)</div></blockquote>
<p>kwargs : keyword arguments to function</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.form_factor">
<code class="descname">form_factor</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.form_factor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns the complex-amplitude of the form factor at the given</dt>
<dd>&lt;F&gt;_d</dd>
</dl>
<p>q-coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.form_factor_distavg_squared">
<code class="descname">form_factor_distavg_squared</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.form_factor_distavg_squared" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id35"><span class="problematic" id="id36">|</span></a>&lt;F&gt;_d|^2</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.form_factor_isotropic">
<code class="descname">form_factor_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.form_factor_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isotropic form factor
&lt; &lt;F&gt;_iso &gt;_d</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.form_factor_squared">
<code class="descname">form_factor_squared</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.form_factor_squared" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the square of the form factor.</p>
<p>&lt;<a href="#id37"><span class="problematic" id="id38">|</span></a>F|^2&gt;_d</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.form_factor_squared_isotropic">
<code class="descname">form_factor_squared_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.form_factor_squared_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isotropic form factor
&lt; &lt;<a href="#id39"><span class="problematic" id="id40">|</span></a>F|^2&gt;_iso &gt;_d</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.rebuild">
<code class="descname">rebuild</code><span class="sig-paren">(</span><em>pargs={}</em>, <em>argdict={}</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows the object to have its potential
arguments (pargs) updated. Note that this doesn&#8217;t
replace the old pargs entirely. It only modifies
(or adds) the key/values provided by the new pargs.</p>
<p>For a polydisperse object, need to update pargs for elements in
distribution, omitting variable that&#8217;s being modified.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.sample_point">
<code class="descname">sample_point</code><span class="sig-paren">(</span><em>dist_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.sample_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a point from a distribution specified by
dist_dict
Currently supported:</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;distribution_type&#8217; (case insensitive) </dt>
<dd><dl class="first last docutils">
<dt>&#8216;Gaussian&#8217; or &#8216;normal&#8217;</dt>
<dd><dl class="first last docutils">
<dt>parameters</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd>&#8216;mean&#8217; : average of Gaussian (normal) distribution
&#8216;sigma&#8217; : standard deviation of Gaussian (normal) distribution</dd>
</dl>
</dd>
<dt>&#8216;uniform&#8217;</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd><dl class="first last docutils">
<dt>parameters</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd>&#8216;low&#8217; : lower bound of distribution
&#8216;high&#8217; : upper bound of distribution</dd>
</dl>
</dd>
<dt>&#8216;lognormal&#8217;</dt>
<dd><dl class="first last docutils">
<dt>parameters:</dt>
<dd>&#8216;mean&#8217; : mean value of underlying normal distribution
&#8216;sigma&#8217; : standard deviation of underlying normal distribution</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.RandomizedNanoObject.volume">
<code class="descname">volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.RandomizedNanoObject.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>ret avg volume</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NanoObjects.SphereNanoObject">
<em class="property">class </em><code class="descclassname">NanoObjects.</code><code class="descname">SphereNanoObject</code><span class="sig-paren">(</span><em>pargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.SphereNanoObject" title="Permalink to this definition">¶</a></dt>
<dd><p>This is as the name of object describes, a sphere.</p>
<dl class="method">
<dt id="NanoObjects.SphereNanoObject.V">
<code class="descname">V</code><span class="sig-paren">(</span><em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.SphereNanoObject.V" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the intensity of the real-space potential at the
given real-space coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.SphereNanoObject.form_factor">
<code class="descname">form_factor</code><span class="sig-paren">(</span><em>qvec</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.SphereNanoObject.form_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the form factor of a sphere.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.SphereNanoObject.form_factor_isotropic">
<code class="descname">form_factor_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.SphereNanoObject.form_factor_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the particle form factor, averaged over every possible orientation.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.SphereNanoObject.form_factor_squared_isotropic">
<code class="descname">form_factor_squared_isotropic</code><span class="sig-paren">(</span><em>q</em>, <em>num_phi=50</em>, <em>num_theta=50</em><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.SphereNanoObject.form_factor_squared_isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the particle form factor squared, averaged over every possible orientation.</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.SphereNanoObject.to_short_string">
<code class="descname">to_short_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.SphereNanoObject.to_short_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a short string describing the object&#8217;s variables.
(Useful for distinguishing objects of the same class.)</p>
</dd></dl>

<dl class="method">
<dt id="NanoObjects.SphereNanoObject.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#NanoObjects.SphereNanoObject.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string describing the object.</p>
</dd></dl>

</dd></dl>

<p>..autoclass: NanoObject</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/NanoObjects.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Yager, Lhermitte, Aaron.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/NanoObjects.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>